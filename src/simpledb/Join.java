package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 * This class is a bit redundant now as AbstractJoin is better suited at its place
 * But I didn't want to change the api for test cases as they expect Join not AbstractJoin.
 * So I decided to use the Join class as a Factory design for join algorithms.
 */
public class Join extends AbstractDbIterator {

	private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private AbstractJoin _joinType = null;
  
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4; 
    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
    	this._predicate = p;
    	this._outerRelation = child1;
    	this._innerRelation = child2;
    }

    public void setJoinAlgorithm(int joinAlgo){
		switch (joinAlgo) {
		case SNL: {
			_joinType = new SNLJoin(_predicate, _outerRelation, _innerRelation);
			break;
		}
		case PNL: {
			_joinType = new PNLJoin(_predicate, _outerRelation, _innerRelation);
			break;
		}
		case SMJ: {
			_joinType = new SMJJoin(_predicate, _outerRelation, _innerRelation);
			break;
		}
		case BNL:
		case HJ:
		default: {
			_joinType = null;
		}
		}
	}

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
    	_joinType.open();
    }

    public void close() {
    	_joinType.close();
    }

	@Override
	public void rewind() throws DbException, TransactionAbortedException, IOException {
		_joinType.rewind();	
	}

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
    	return _joinType.readNext();
    }

	@Override
	public TupleDesc getTupleDesc() {
		return _joinType.getTupleDesc();
	}

	public int getNumMatches() {
		return _joinType.getNumMatches();
	}
	
	public int getNumComp() {
		return _joinType.getNumComp();
	}
}
